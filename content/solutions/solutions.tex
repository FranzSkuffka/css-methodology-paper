\subsection*{Scope Leaks}
To this date, while some browsers support scoped \verb <style> -tags, the CSS scoping module level 1 is still in draft.\footnote{cf. \cite{cssscopingmodule}}\footnote{cf. \cite{styletag}}
The \gls{w3c}-draft on CSS scoping defines a syntax that is similar to that of media queries.
However, media queries no not operate based on the \gls{dom}-structure but are scoping styles based on various properties of the rendering device.\footnote{cf. \cite{mediaqueries}}
Here it is possible to surround a set of rules with a selector that, if matched, limits these rules' scope to children of the matched element.
\begin{verbatim}
@scope div {
  span {
  color: blue;
  }
}
\end{verbatim}
In terms of limiting the visibility of rules this has the exact same effect as prefixing it with that selector.\footnote{cf. \cite{cssscopingmodule}}
% syntactic sugar, other selector, tab atkins

A selector chain with more than one selector scopes the rule by the first selector:
\begin{verbatim}
.sidebar span {
  background: red;
}
.sidebar a {
  color: blue;
}
\end{verbatim}
\begin{figure}
\caption{The rules are scoped within the context of sidebar elements}
\end{figure}

The usage of this technique is often observed to limit the scope of styles to a specific page.
Coyier introduced and Escalante recommends decorating decorating the body tag of each \gls{html} document of a project with an ID.\footnote{cf. \cite{coyieridbody}}\footnote{cf. \cite{mpgcss}}
The major use case for page or page-type specific styles is the creation of visual exceptions among all pages.
Generally, page-specific styles may be used to define visual cues as visual orientation aids.
A concrete example for this is a visual design specification that distinguishes the header of an article page through a an opaque background instead of being  a transparent layer over a darker image.

\begin{verbatim}
header {
  background: transparent;
}
#article header {
  background: black;
}
\end{verbatim}

Coyier also exemplifies the use of page-specific styles through highlighting the currently selected entry of the main menu without changing the markup of the latter.

\begin{verbatim}

// index.html

<body id='about'>
  <nav>
    <ul>
      <li class='nav-item home'>
      <li class='nav-item about'>
    ...


// style.css

nav li {}

#about .nav-item.about {}

\end{verbatim}

However this technique should be applied with caution.
The markup and the styles in this example are coupled tightly and effectively violate the principle of \gls{soc}.
Each navigation entry requires an additional rule to function correctly in the context of the user interface.
Because this leads to bloat in \gls{css} code when the number of navigation entry is growing, a dynamic \gls{js} client- or server-side solution modifying the markup might be more when aiming for scalability.

The methodologies \gls{bem} and \gls{suit} share the concept of creating indivisble blocks in both .
Blocks encapsulate \gls{html} and \gls{css} as well as `other implementation technologies'\footnote{\cite{bem}}  and are also referred to as `components'.\footnote{cf. \cite{suit}}\footnote{cf. \cite{bem}} 
\gls{suit} is inspired by and may be viewed as being evolved from \gls{suit}.
Both have very similar conventions for the construction of \gls{css} rule selectors and the related markup.
The following example displays the construction of component and child-element selectors in \gls{suit}.
snake/dash/camel case

\begin{verbatim}
.BlockName {}

.BlockName-descendantName {}
\end{verbatim}
Whereas the delimiters can be chosen freely in \gls{bem} the naming conventions are more specific for \gls{suit}.
The reason for capitalising the root node selector is to avoid name collisions and thus expectedly better integration with existing code.\footnote{cf. \cite{bemvssuitquestion}}
The example shows that the scoping here does not utilise the cascade but works through prefixing the actual class names.
Descendent styles are applied to elements decorated with the classname \verb ComponentName-descendantName , regardless of their position in the \gls{dom}.

Escalante criticises this approach.
Instead of leveraging the functionality of the cascade, \gls{bem} and \gls{suit} annul it to `replicate it [...] in a less efficient manner'.\footnote{\cite{mpgcss}}
Inheriting the class name of the block root into the class name of a descendant causes repetitition and thus redundancy in the \gls{html}.\footnote{cf. \cite{mpgcss}}
{\slshape Title CSS} leverages the cascade to create a scope.
Through separating the block identifier as distinct class, repetition within the \gls{html}-markup is avoided:

\begin{verbatim}
.BlockName {}

.BlockName .descendantName{}
\end{verbatim}
Besides avoiding repetition, Cuthbert adds ease-of-writing as well as readability as rationales for {\slshape Title CSS} as naming convention.
After presenting methods for avoiding scope leaks in \gls{css}, methods to avoid redundancy within \gls{css} files are presented in the following section.

% performance
% utility
% - overriding 
% shadowing





\subsection*{Violations of the DRY Principle}
There are several tools and methods available that allow eliminating repetitions in \gls{css}-code.
Variables are, to this date, only fully supported by Firefox 31 and has been removed as an experimental feature in Google Chrome from version 33 to 34.\footnote{cf. \cite{cssvariables}}
To eliminate the duplication constants are sufficient.
Besides variables there are no native gls{css} means to emulate constants in their classical definition.

All common \gls{css}-Preprocessors provide a variable feature.
These variables are only variable during the actual processing and not at interpretation-time.
Thus preprocessor variables are effectively constants.\footnote{cf. \cite{wirthpreprocessors} p.27}
Using preprocessors allows eliminating repetition in the source code to some degree
but the repetition will still be observable in the processed \gls{css}.
Verou assumes that the usage of preprocessors may result in the developer `losing track of CSS filesize'.\footnote{cf. \cite{veroupreprocessors}}
This potential may not be as big when using preprocessed variables, but bigger for other language features like mixins.
% information size
% bandwidth for user

An approach to completely eliminate repetition in native \gls{css} code is Atomic \gls{css}, presentend in 2013 by Koblentz, frontend developer at Yahoo.
It advocates splitting the \gls{css} source code in the smallest possible parts.
This effectively decouples the \gls{css} from the structure of the \gls{html} document.
Atomic \gls{css} rules represent a specific visual appearance.
The class names of the individual rules are not semantic but representational.

% approach by frameworks, high reusability

\begin{verbatim}
.Mend-small {
    margin-left: 10px;
}
\end{verbatim}

In contrast to block-based approaches like \gls{suit} and \gls{bem} Atomic CSS is no scoping and no nesting.
Rules do not have a specific context and thus are highly reusable.\footnote{cf. \cite{atomiccssarticle}}
There are multiple tradeoffs to the Atomic CSS approach:

\begin{itemize}
    \item {\normalfont \bfseries Additional classes in markup:} Visual attributes are grouped through class assignment rather than below a specific selector.
        This means more classes need to be assigned to each element whose visual appearence deviates from default and base styles.
        The resulting markup may be considered bloated.

    \item {\normalfont \bfseries Non-semantic class names:} Because of the radical decoupling the \gls{css} rules are named by the visual attribute they yield. 
        The lack of scoping possibly impedes the developer's ability to localize the effect of changes.

    \item {\normalfont \bfseries Changing names and unused rules:} The W3C states that `Good names don't change'.\footnote{\cite{classsemantics}}
        The Usage of class names that inherit attribute values are a violation of \gls{dry}. 
        Replacing these attribute values with names like \verb small may eleminate the need to change class names when the actual attribute values change.
\end{itemize}

The development of the Atomic CSS approach has since been continued by Yahoo.
Current versions do not involve direct editing of \gls{css}-files.
The semantic hierarchy between class names and attributes is inversed.
Class names define the actual style attributes.
Atomizer, a build tool that extracts \gls{css} rules from the definitions in the markup is used to generate gls{css}-files.
Atomizer supports the usage of variables.
Whereas an overhead of unused rules in the \gls{css}-files is prevented by this approach, the markup is still studded with non-semantically named classes.\footnote{cf. \cite{atomiccsssite}}



% vs inline styles
% applying and de-applying classes, meaning of classes, logic has to be stored in module context
Atomizer is an additional build tool which is why we do not examine this any further.


% Modules / Components
% modifiers on components or elements
% balance between repeating 





% no variables
% repeated within the markup
% 
% respect to SOLID design principles\footnote{cf. \cite{solidcss}}
% sub-classes = re-usability through dry
% cascade

% DRY Principle \footnote{cf. \cite{pragmaticprogrammer}}
% low reusability
% - specificity
% - tight coupling with markup
% 
% DRY CSS: breaks code structure
