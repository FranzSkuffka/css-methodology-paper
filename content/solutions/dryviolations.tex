\subsection{Violations of the DRY Principle}
There are several tools and methods available that allow eliminating repetitions in \gls{css}-code.
Variables are, to this date, only fully supported by Firefox 31 and has been removed as an experimental feature in Google Chrome from version 33 to 34.\footnote{cf. \cite{cssvariables}}
To eliminate the duplication constants are sufficient.
Besides variables there are no native gls{css} means to emulate constants in their classical definition.

All common \gls{css}-Preprocessors provide a variable feature.
These variables are only variable during the actual processing and not at interpretation-time.
Thus preprocessor variables are effectively constants.\footnote{cf. \cite{wirthpreprocessors} p.27}
Using preprocessors allows eliminating repetition in the source code to some degree
but the repetition will still be observable in the processed \gls{css}.
Verou assumes that the usage of preprocessors may result in the developer `losing track of CSS filesize'.\footnote{cf. \cite{veroupreprocessors}}
This potential may not be as big when using preprocessed variables, but bigger for other language features like mixins.
% information size
% bandwidth for user

An approach to completely eliminate repetition in native \gls{css} code is Atomic \gls{css}, presentend in 2013 by Koblentz, frontend developer at Yahoo.
It advocates splitting the \gls{css} source code in the smallest possible parts.
This effectively decouples the \gls{css} from the structure of the \gls{html} document.
Atomic \gls{css} rules represent a specific visual appearance.
The class names of the individual rules are not semantic but representational.

% approach by frameworks, high reusability

\lstset{language=CSS3,caption={Atomic CSS Rule}}
\begin{lstlisting}
.Mend-small {
    margin-left: 10px;
}
\end{lstlisting}

In contrast to block-based approaches like \gls{suit} and \gls{bem} Atomic CSS is no scoping and no nesting.
Rules do not have a specific context and thus are highly reusable.\footnote{cf. \cite{atomiccssarticle}}
There are multiple tradeoffs to the Atomic CSS approach:

\begin{itemize}
    \item {\normalfont \bfseries Additional classes in markup:} Visual attributes are grouped through class assignment rather than below a specific selector.
        This means more classes need to be assigned to each element whose visual appearence deviates from default and base styles.
        The resulting markup may be considered bloated.

    \item {\normalfont \bfseries Non-semantic class names:} Because of the radical decoupling the \gls{css} rules are named by the visual attribute they yield. 
        The lack of scoping possibly impedes the developer's ability to localize the effect of changes.

    \item {\normalfont \bfseries Changing names and unused rules:} The W3C states that `Good names don't change'.\footnote{\cite{classsemantics}}
        The Usage of class names that inherit attribute values are a violation of \gls{dry}. 
        Replacing these attribute values with names like \verb small may eleminate the need to change class names when the actual attribute values change.
\end{itemize}

The development of the Atomic CSS approach has since been continued by Yahoo.
Current versions do not involve direct editing of \gls{css}-files.
The semantic hierarchy between class names and attributes is inversed.
Class names define the actual style attributes.
Atomizer, a build tool that extracts \gls{css} rules from the definitions in the markup is used to generate gls{css}-files.
Atomizer supports the usage of variables.
Whereas an overhead of unused rules in the \gls{css}-files is prevented by this approach, the markup is still studded with non-semantically named classes.\footnote{cf. \cite{atomiccsssite}}



% vs inline styles
% applying and de-applying classes, meaning of classes, logic has to be stored in module context
Atomizer is an additional build tool which is why we do not examine this any further.


% Modules / Components
% modifiers on components or elements
% balance between repeating 





% no variables
% repeated within the markup
% 
% respect to SOLID design principles\footnote{cf. \cite{solidcss}}
% sub-classes = re-usability through dry
% cascade

% DRY Principle \footnote{cf. \cite{pragmaticprogrammer}}
% low reusability
% - specificity
% - tight coupling with markup
% 
% DRY CSS: breaks code structure
